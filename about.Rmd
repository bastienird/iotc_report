---
title: "IOTC Data Analisys (Comparison Georef to Global and conversion factors)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author:
  - name: Bastien Grasset
    email: bastien.grasset@ird.fr
    affiliation:
      - IRD
      - MARBEC
  - name: Julien Barde
    affiliation:
      - IRD
      - MARBEC
address:
  - code: IRD
    address: Institut de Recherche pour le Développement (IRD), av. Jean Monnet, CS 30171, 34203 Sète cédex, France
  - code: MARBEC
    address: MARBEC, University of Montpellier, CNRS, Ifremer, IRD, Sète, France
csl: dmk-format.csl
link-citations: TRUE
output:
  bookdown::gitbook:
    config:
      toc:
        collapse: subsection
        scroll_highlight: true
        before: null
        after: null
  bookdown::pdf_document2:
    latex_engine: lualatex 
    extra_dependencies: ["adjustbox", "subfig", "flafter", "makecell"]
    toc: TRUE
    keep_tex: TRUE
    template: template.tex
    #md_extensions: "-autolink_bare_uris"
    number_sections: TRUE
    citation_package: default # Can also be "natbib"
    always_allow_html: TRUE
    keep_md: TRUE
abstract: "This document provide an overview of inconsistency in FIRMS level 0 and FIRMS nominal IOTC data that creates issues with final IRD LVL 2 data. When possible, some explenations are provided to explain those inconsistencies, however the results shows that the available explenations do not cover the entire issues."
geometry: "margin=20mm"
papersize: a4
endfloat: FALSE
numberlines: FALSE
authblk: FALSE
footnotehyper: FALSE
urlcolor: blue
linkcolor: blue
citecolor: blue
graphics: TRUE
tables: TRUE
fancyhdr:
  first:
    headleft: "Global Tuna Atlas outputs and process"
    headright: "2023"
    headrulewidth: 0pt
  subsequent:
    headleft: "Global Tuna Atlas outputs and process"
    headright: "2023"
    headrulewidth: 1pt
    footrulewidth: 0pt
---

In the following document:
The total of the strata in georereferenced dataset for which an equivalent strata exist in the nominal dataset but is inferior will be call **georef_sup_nom** (with the corresponding dimensions of the stratas ex: species/year or species/year/gear_type etc...). 
The total of stratas in the georeferenced dataset for whihc an equivalent does not exist in the nominal dataset (concerning thus values in tons but also number of fish) will be named **georef_no_nom**.

Dans ce rapport on tente de mettre en évidence et d'expliquer certaines incohérences entre différents jeux de données. Le cas est ici IOTC mais on retrouve des incohérences similaires pour chaque tRFMO. 


```{r setup, include=FALSE}

knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
base::options(knitr.duplicate.label = "allow")

```


```{r functions}

source("https://raw.githubusercontent.com/firms-gta/geoflow-tunaatlas/master/tunaatlas_scripts/generation/download_zenodo_csv.R")
source("https://raw.githubusercontent.com/firms-gta/geoflow-tunaatlas/master/Analysis_markdown/functions/Functions_markdown.R")
source("https://raw.githubusercontent.com/firms-gta/geoflow-tunaatlas/master/tunaatlas_scripts/generation/download_zenodo_csv.R")
source("https://raw.githubusercontent.com/firms-gta/geoflow-tunaatlas/master/Analysis_markdown/functions/time_coverage_analysis.R")
source("https://raw.githubusercontent.com/firms-gta/geoflow-tunaatlas/master/Analysis_markdown/functions/Groupping_differences.R")
source("https://raw.githubusercontent.com/firms-gta/geoflow-tunaatlas/master/Analysis_markdown/functions/compare_strata_differences.R")

formals(qflextable2)$pgwidth = 0.5

compare_nominal_georef_corrected <- function(nominal, georef_mapped, list_strata = list(c("species", "year", "source_authority", "gear_type", "fishing_fleet"))) {
  # Convertir les data.frames en data.tables
  setDT(nominal)
  setDT(georef_mapped)
  
  # Créer la colonne "year" à partir de time_start
  georef_mapped[, year := as.character(year(ymd(time_start)))]
  nominal[, year := as.character(year(ymd(time_start)))]
  
  # Conserver uniquement les données en tonnes
  georef_mapped_tons <- georef_mapped[measurement_unit == "t"]
  
  # Initialise une liste pour stocker les résultats (un résultat pour chaque liste de dimensions à conserver pour faire la comparaison)
  results <- list()
  
  for (strata in list_strata) {
    # Nom pour la catégorie actuelle de strata
    name <- paste0(toString(strata))
    
    # Agréger les données pour le nominal et georef sur les colonnes spécifiées dans 'strata' (ex groupper les données par années, espèces, engins, pavillon)
    nominal_grouped <- nominal[, .(measurement_value_nominal = sum(measurement_value, na.rm = TRUE)), by = strata]
    georef_mapped_grouped <- georef_mapped[, .(measurement_value_georef = sum(measurement_value, na.rm = TRUE)), by = strata]
    georef_mapped_tons_grouped <- georef_mapped_tons[, .(measurement_value_georef_tons = sum(measurement_value, na.rm = TRUE)), by = strata]
    
    # # Retirer les valeurs des colonnes pour comparer uniquement les strates (si on veut garder que elles)
    nominal_grouped_without_value <- nominal_grouped[, .SD, .SDcols = strata]
    georef_grouped_without_value <- georef_mapped_grouped[, .SD, .SDcols = strata]
    georef_tons_grouped_without_value <- georef_mapped_tons_grouped[, .SD, .SDcols = strata]

    
    # # Assurer que les colonnes sont dans le même ordre pour la comparaison
    setcolorder(georef_grouped_without_value, names(nominal_grouped_without_value))
    setcolorder(georef_tons_grouped_without_value, names(nominal_grouped_without_value))
    
    # Trouver les strates présentes dans georef_mapped mais absentes de nominal
    georef_no_nominal <- fsetdiff(georef_grouped_without_value, nominal_grouped_without_value, all = FALSE)
    georef_no_nominal_with_value <- merge(georef_mapped_tons_grouped, georef_no_nominal, by = strata, all = FALSE)
    sum_georef_no_nominal_tons <- sum(georef_no_nominal_with_value$measurement_value_georef_tons ,na.rm = TRUE)
    
    
    # Comparer uniquement les données en tonnes
    georef_tons_no_nominal <- fsetdiff(georef_tons_grouped_without_value, nominal_grouped_without_value, all = FALSE)
    
    # Comparer les valeurs des strates communes entre nominal et georef_mapped pour les données en tonnes
    georef_sup_nominal <- merge(nominal_grouped, georef_mapped_tons_grouped, by = strata, all = FALSE)

        # Vérifier si les colonnes existent après le merge
    if ("measurement_value_georef_tons" %in% names(georef_sup_nominal) && 
        "measurement_value_nominal" %in% names(georef_sup_nominal)) {
      georef_sup_nominal[, Difference := measurement_value_georef_tons - measurement_value_nominal]
      georef_sup_nominal <- georef_sup_nominal[round(Difference, 3) > 1] # Supérieur strictement à 1, on s'affranchit des petits kouaks
    } else {
      georef_sup_nominal <- data.table()  # Retourne une table vide s'il n'y a pas de données
    }
    
 if ("fishing_fleet" %in% colnames(georef_sup_nominal)){
    tons_nei_georef <- georef_no_nominal_with_value[
  fishing_fleet == "NEI" ,
  sum(measurement_value_georef_tons)] + georef_sup_nominal[
  fishing_fleet == "NEI" ,
  sum(measurement_value_georef_tons) 
    ]} else {
  tons_nei_georef <- 0
    }
    
    tons_aggregated_georef <- georef_no_nominal_with_value[
 species %in% c("TUN", "TUS" ,"BIL"),
  sum(measurement_value_georef_tons)
] + georef_sup_nominal[
 species %in% c("TUN", "TUS" ,"BIL"),
  sum(measurement_value_georef_tons)
]
    
    if ("fishing_fleet" %in% colnames(nominal_grouped)){
tons_nei_nominal <- nominal_grouped[
  fishing_fleet == "NEI",
  sum(measurement_value_nominal)
]} else {tons_nei_nominal <- 0}


sum_georef_sup_nom <- sum(georef_sup_nominal$Difference, na.rm = TRUE)

  suffisant <- ifelse(sum_georef_no_nominal_tons + sum_georef_sup_nom -(tons_aggregated_georef + tons_nei_georef) > 0, FALSE, TRUE)
    # Stocker les résultats
    results[[name]] <- list(
      georef_no_nominal = georef_no_nominal,           # Strates dans georef mais absentes dans nominal
      georef_no_nominal_with_value = georef_no_nominal_with_value %>% dplyr::rename(measurement_value = measurement_value_georef_tons),           # Strates dans georef mais absentes dans nominal avec la valeur totale
      georef_tons_no_nominal = georef_tons_no_nominal, # Strates en tonnes absentes dans nominal
      georef_sup_nominal = georef_sup_nominal,          # Strates où georef est supérieur à nominal
      tons_nei_nominal = tons_nei_nominal,          # Strates nei qui pourraient expliquer les différences
      tons_nei_georef = tons_nei_georef,          # Strates nei qui pourraient expliquer les différences
      sum_georef_no_nominal = sum_georef_no_nominal_tons, 
      suffisant = suffisant, 
      tons_aggregated_georef = tons_aggregated_georef,
      sum_georef_sup_nom = sum_georef_sup_nom
    )
  }
  
  return(results)
}

datatable2 <- function(df, options = list(scrollX = TRUE), ...) {
  df[] <- lapply(df, function(x) if(is.numeric(x)) round(x, 3) else x)
  df <- df %>% head(100)
  # Combiner les options par défaut avec celles passées en argument
  options <- modifyList(list(scrollX = TRUE), options)
  
  # Appeler la fonction datatable originale
  DT::datatable(df, options = options, ...)
}


```



```{r package}

require(readr)
require(futile.logger)
require(reshape2)
library(data.table)
library(lubridate)
require(here)
require(dplyr)
require(ggplot2)
require(cowplot)
require(RColorBrewer)
require(flextable)
require(tidyr)
require(stringr)
require(DT)

```


```{r, cache=TRUE}

if (!file.exists(here::here("data/global_nominal_catch_firms_level0_harmonized.csv"))) {
  # Télécharger le fichier si nécessaire
  nominal_init <- download_zenodo_csv("10.5281/zenodo.11410529", "global_nominal_catch_firms_level0_harmonized.csv")
  readr::write_csv(nominal_init, here::here("data/global_nominal_catch_firms_level0_harmonized.csv"))

} else {
  nominal_init <- readr::read_csv(here::here("data/global_nominal_catch_firms_level0_harmonized.csv"))
}

if (!file.exists(here::here("data/global_catch_firms_level0_harmonized.csv"))) {
  # Télécharger le fichier si nécessaire
    level0 <- download_zenodo_csv("10.5281/zenodo.11460074", "global_catch_firms_level0_harmonized.csv")
    readr::write_csv(level0, here::here("data/global_catch_firms_level0_harmonized.csv"))
} else {
      level0 <- readr::read_csv(here::here("data/global_catch_firms_level0_harmonized.csv"))
}

nominal <- nominal_init%>% dplyr::filter(source_authority == "IOTC") %>% dplyr::filter(species %in% c("ALB", "BET", "YFT", "SKJ", "SWO", "TUN", "TUS", "BIL")) #%>% dplyr::select(-source_authority)
lvl0 <-level0 %>% dplyr::filter(source_authority == "IOTC")%>% dplyr::filter(species %in% c("ALB", "BET", "YFT", "SKJ", "SWO", "TUN", "TUS", "BIL")) #%>% dplyr::select(-source_authority)


list_stratalist <- list(c("species", "year"), c("species", "year", "gear_type"),  c("species", "year", "gear_type", "fishing_fleet"), c("species", "year", "fishing_fleet"))

lvl0_strata <- compare_nominal_georef_corrected(nominal , lvl0, list_strata = list_stratalist)

```


# Première partie: Données géoreferencées supérieures aux données nominales avec ou sans correspondance

## Explication de la méthode d'analyse: exemple pour le cas espèces/années

On grouppe toutes les strates géoreferencées par espèces années pour le jeu géoreferencé et le jeu nominal et on somme pour les captures uniquement en tonnes. 

On se retrouve avec des tables de cette forme: 

```{r}

qflextable2(head(lvl0_strata$`species, year`$georef_sup_nominal) %>% dplyr::select(species, year, measurement_value = measurement_value_georef_tons), captionn = "Aggrégation georef espèces/année (exemple illustratif)")

qflextable2(head(lvl0_strata$`species, year`$georef_sup_nominal) %>% dplyr::select(species, year, measurement_value = measurement_value_nominal), captionn = "Aggrégation nominale espèces/année (exemple illustratif)")


```

On joint ces différentes strates et on conserve celle pour lesquelles les données nominales sont inférieures aux données georeferencées.


```{r}

qflextable2(head(lvl0_strata$`species, year`$georef_sup_nominal), captionn = "Strates supérieures en georef que en nominales sur comparaison espèces/année")

```

On reproduit cette méthode pour différentes strates, ce qui créera des résultats différents et plus de données présentant des georef_sup_nom/georef_no_nom au fur et à mesure qu'on ajoute des dimensions.

### Les données georeferencées sans correspondance avec les nominales pour les strates espèces années

```{r include=FALSE}

lvl0_strata$`species, year`$sum_georef_no_nominal # 268 976.6
lvl0_strata$`species, year`$tons_aggregated_georef # 268 976.6
species_no_nom <- pie_chart_2_default("species", lvl0_strata$`species, year`$georef_no_nominal_with_value %>% dplyr::mutate(measurement_unit = "Tons"), titre_1 = "",title_yes_no =FALSE)

```

```{r fig.cap="Répartition en pourcentage par espèces des données géoreferencées sans correspondances nominales"}
species_no_nom
```


Toutes les données georef no nominales sont observées pour des espèces correspondants à des aggregation d'espèces (BIL, TUN, TUS). Cela semble logique car les données géreferencées sont plus aggrégées que les données nominales. Il n'y a donc pas de strates géoreferencées sans correspondance en nominal pour ces dimensions espèces/engins.


### Les données georeferencées supérieures aux nominales pour les strates espèces années 

NB: Il n'y a pas d'espèces aggrégées dans les nominales tels que TUN, TUS ou BIL pour expliquer ces différences.

```{r}

qflextable2(lvl0_strata$`species, year`$georef_sup_nominal, captionn = "Strates supérieures en Georef que en nominales sur comparaison espèces/année")

```

Il y a 10 000 tonnes au total de données supérieures en georeferencées, ça représente pas grand chose au total et peut très bien venir d'erreur à la marge sans remettre en cause le prisme de comparaison qui est que les données nominales devraient toujours être supérieur aux données géoreferencées pour une même strate. Ceci pourrait-on augmenter les données nominales sur cette base ? Baisser les données georeferencées?

La question se pose pour IOTC mais également pour toutes les autres tRFMOs (excepté CCSBT).



## Exemple pour le cas global avec des strates pour chaque dimension

```{r}

lvl0_strata_all <- compare_nominal_georef_corrected(nominal , lvl0, list_strata = list(c("species", "gear_type", "fishing_mode", "year", "fishing_fleet")))

nombre_strates_sup_ou_no <- nrow(lvl0_strata_all$`species, gear_type, fishing_mode, year, fishing_fleet`$georef_no_nominal) + nrow(lvl0_strata_all$`species, gear_type, fishing_mode, year, fishing_fleet`$georef_sup_nominal)

tonnes <- sum(lvl0_strata_all$`species, gear_type, fishing_mode, year, fishing_fleet`$georef_no_nominal_with_value$measurement_value) + sum(lvl0_strata_all$`species, gear_type, fishing_mode, year, fishing_fleet`$georef_sup_nominal$Difference)

especes <- unique(lvl0_strata_all$`species, gear_type, fishing_mode, year, fishing_fleet`$georef_no_nominal$species)

lvl0_t <- lvl0 %>% dplyr::filter(measurement_unit == "t")
sum_lvl0 <- sum(lvl0_t$measurement_value)

```

En prenant toute les dimensions, le nombre de strate sans correspondance ou supérieur est de `r nombre_strates_sup_ou_no` strate soit `r round(nombre_strates_sup_ou_no*100/nrow(lvl0),3)` % du nombre de strates du niveau 0. Cela représente `r tonnes` tonnes soit `r round(tonnes*100/sum_lvl0,3)`

Toutes les espèces conservées dans cette analyse sont concernées. On analyse succintement ces strates pour essayer de comprendre d'ou peuvent venir ces incohérences. Pour simplifier nous allons dans un premier temps analyse les données avec des strates aux dimensions plus réduites tel que année/espèces/pavillon ou année/espèces/engin pour simplifier.

## Comparaison strates espèces années fishing_fleet et espèces années gear_type

On cherche à choisir quel dimension ajouter en premier pour analyser les différences avec plus de finesse.

Pour choisir il faudrait savoir s'il y a plus de chance de report de donnés d'un engin à un autre ou d'un fishing_fleet à un autre (en georeferencé ou en nominal). 
On note qu'il n'y a au niveau nominal et pour ces dimensions la possibilité que des strates renseignées "NEI" soient à l'origine des différences observées avec les géoreferencées. Les aggrégations en 99.9 ou BIL, TUN, TUS possibles pour les données georeferencées pourraient dans certains cas expliquer une partie des différences présentées ci-dessous.

### Georef_sup_nom

```{r georefsupnomstff}

georef_sup_nom_st_ff <- as.data.frame(lvl0_strata$`species, year, fishing_fleet`$georef_sup_nominal) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(measurement_value = Difference) %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

georef_sup_nom_st_gear <- as.data.frame(lvl0_strata$`species, year, gear_type`$georef_sup_nominal) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(measurement_value = Difference) %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

georef_no_nom_st_ff <- as.data.frame(lvl0_strata$`species, year, fishing_fleet`$georef_no_nominal_with_value) %>% dplyr::mutate(measurement_unit = "t")  %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

georef_no_nom_st_gear <- as.data.frame(lvl0_strata$`species, year, gear_type`$georef_no_nominal_with_value) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

georef_sup_nom <- as.data.frame( lvl0_strata$`species, year`$georef_sup_nominal) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(measurement_value = Difference) %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

georef_no_nom <- as.data.frame(lvl0_strata$`species, year`$georef_no_nominal_with_value) %>% dplyr::mutate(measurement_unit = "t") %>%  dplyr::mutate(time_start = paste0(year , "-01-01"))

```

```{r}

binding_st_ff <- rbind(georef_sup_nom_st_ff %>% dplyr::mutate(measurement_unit = "Georef_sup_nom") %>% dplyr::select(species, year, time_start,measurement_value, measurement_unit, fishing_fleet), georef_no_nom_st_ff%>% dplyr::mutate(measurement_unit = "Georef_no_nom"))

binding_st_gear <- rbind(georef_sup_nom_st_gear %>% dplyr::mutate(measurement_unit = "Georef_sup_nom") %>%  dplyr::select(species, year,time_start, measurement_value,measurement_unit, gear_type), georef_no_nom_st_gear%>% dplyr::mutate(measurement_unit = "Georef_no_nom"))

summary_of_differences_st_ff_vs_gear <- compute_summary_of_differences(binding_st_ff, binding_st_gear, "Dimensions year/species/fishing_fleet", "Dimensions year/species/gear_type") %>% dplyr::rename("Type of data" = measurement_unit)

```


```{r}

qflextable2(summary_of_differences_st_ff_vs_gear, caption = "Differences de données georeferencées supérieures aux nominales et géoreferencées sans nominales pour différentes strates")

```

Au total il y a beaucoup plus de différence entre les strates géoreferencées et nominales si on conserve les dimensions espèces/années/engins que espèces/années/pavillons (même énormément plus pour les données sans nominales). On remarque aussi qu'il y a une espèce en plus : "YFT" en conservant les engins pour la comparaison qu'en conservant les pavillons.

On regarde ces différences en fonction des années pour s'assurer de la  tendance générale et écarter un potentiel événement ponctuel qui influencerait le total.


```{r}

time_coverage_analysis_list_st_ff <- time_coverage_analysis(list(fonction_groupement("time_start", georef_sup_nom_st_ff, georef_sup_nom_st_gear )), "time_start", titre_1 = "georef_sup_nom_st_ff",titre_2 = "georef_sup_nom_st_gear")

```


```{r, fig.cap = time_coverage_analysis_list_st_ff$titles[1]}

time_coverage_analysis_list_st_ff$plots[[1]]

```

On voit que pour la majorité des années, lisser les différences nom/geo en regroupant les pavillons plutôt qu'en regroupant les engins permet de réduire ces différences. On peut donc supposer que ces problèmes proviennent de reports entre des engins pour une même strate. Le problème pourrait donc venir d'un mapping différent d'engins entre les nominal et les géoreferencés. Cela ouvre une piste de réflexion pour un lvl2 RF2 avec plutôt un regroupement d'engins à la place de pavillon.

NB: On ne peut pas comparer uniquement les georef_sup_nom sans les georef_no nom quand on regarde des strates de dimensions différentes car il y a des reports entre les no_noms et les sup_nom différents.


### Georef_no_nom

```{r}

time_coverage_analysis_list_st_ff_vs_gear <- time_coverage_analysis(list(fonction_groupement("time_start", georef_no_nom_st_ff, georef_no_nom_st_gear %>% dplyr::mutate(time_start = paste0(year , "-01-01")) )), "time_start", titre_1 = "georef_no_nom_st_ff",titre_2 = "georef_no_nom_st_gear")

```


```{r, fig.cap = time_coverage_analysis_list_st_ff_vs_gear$titles[1]}

time_coverage_analysis_list_st_ff_vs_gear$plots[[1]]

```

Pour l'intégralité des années, lisser les différences nom/geo en regroupant les pavillons plutôt qu'en regroupant les engins permet de réduire ces différences. On peut donc supposer que ces problèmes proviennent de reports entre des engins pour une même strate. Le problème pourrait donc venir d'un mapping différent d'engins entre les nominal et les géoreferencés. Cela ouvre une piste de réflexion pour un lvl2 RF2 avec plutôt un regroupement d'engins à la place de pavillon (en tout cas pour IOTC).

### Conclusion sur le choix des dimensions

Pour IOTC la dimension fishing_fleet semble être plus cohérente pour une comparaison/élévation au niveau 2. On analyse donc par la suite pour plus de précision les différences entre géoreferencées et nominales pour des strates de même valeur pour les dimensions années/espèces/pavillons.

## Strates espèces années pavillons

### Les données géoreferencées sans correspondance nominales (années/espèces/pavillons)

```{r fig.cap="Georef_no_nom strate espèces/engins/années"}

datatable2(lvl0_strata$`species, year, fishing_fleet`$georef_no_nominal_with_value)

```

```{r}

georef_no_nom_st_ff <- as.data.frame(lvl0_strata$`species, year, fishing_fleet`$georef_no_nominal_with_value) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(year = as.character(year))

species_no_nom_st_ff <- pie_chart_2_default("species", georef_no_nom_st_ff, titre_1 = "",title_yes_no =FALSE)

fishing_fleet_no_nom_st_ff <- pie_chart_2_default("fishing_fleet", georef_no_nom_st_ff, titre_1 = "",title_yes_no =FALSE)

sum_georef_no_nominal_st_ff <- lvl0_strata$`species, year, fishing_fleet`$sum_georef_no_nominal

sum_nei_nominal_gr <- lvl0_strata$`species, year, fishing_fleet`$tons_nei_nominal

```

```{r, results='asis'}

render_subfigures(list(fishing_fleet_no_nom_st_ff, species_no_nom_st_ff), list("Codes espèces", "Codes pavillons"), general_title = "Proportion relative des captures géoreferencées sans strates correspondantes en nominales pour une comparaison sur des strates de dimensions espèces/années/pavillons")

```

Ce sont surtout en tonnes des données pour SKJ et YFT, et notamment pour 09.2 (lignes mécanisées et lignes à cannes mécaniques). Elles représenent un total de `r sum_georef_no_nominal_st_ff` tonnes soit `r round((sum_georef_no_nominal_st_ff *100 ) /lvl0 %>% dplyr::filter(measurement_unit == "t") %>% dplyr::summarise(sum = sum(measurement_value)) %>% dplyr::pull())`% des données totales.

### Les données georeferencées supérieures aux nominales pour les strates espèces années pavillons

```{r, fig.cap = "Georef_sup_to_nom strate espèces/pavillons/années"}

datatable2((lvl0_strata$`species, year, fishing_fleet`$georef_sup_nominal))

```


```{r}

time_coverage_analysis_list_st_ff <- time_coverage_analysis(list(fonction_groupement("time_start", georef_sup_nom_st_ff, georef_sup_nom )), "time_start", titre_1 = "Georef_sup_nominal_st_ff",titre_2 = "Georef_sup_nominal_year_species")
```

```{r include=FALSE}
sum_georef_sup_nominal_st_ff <- lvl0_strata$`species, year, fishing_fleet`$sum_georef_sup_nom

sum_georef_sup_nominal <- lvl0_strata$`species, year`$sum_georef_sup_nom

# georef_sup_nom_andgeoref_no_nom_st_ff <- lvl0_strata$`species, year, fishing_fleet`$sum_georef_no_nominal + lvl0_strata$`species, year, fishing_fleet`$sum_georef_sup_nom # 587 284.4  + 4 209 992 = 4 797 276
# lvl0_strata$`species, year, fishing_fleet`$tons_aggregated_georef # = 268 977
# lvl0_strata$`species, year, fishing_fleet`$tons_nei_georef # 0 

```

Elles représentent un total de `r round(sum_georef_sup_nominal_st_ff)` tonnes soit `r round((sum_georef_sup_nominal_st_ff *100 ) /lvl0 %>% dplyr::filter(measurement_unit == "t") %>% dplyr::summarise(sum = sum(measurement_value)) %>% dplyr::pull(),3)`% des données totales contre  `r round((sum_georef_sup_nominal *100 ) /lvl0 %>% dplyr::filter(measurement_unit == "t") %>% dplyr::summarise(sum = sum(measurement_value)) %>% dplyr::pull(),3)`% avant. On voit que l'augmentation est plus prononcée entre les années 90 et 2010.

```{r}

binding_st_species_year <- rbind(georef_sup_nom %>% dplyr::mutate(measurement_unit = "Georef_sup_nom") %>%  dplyr::select(species, year,time_start, measurement_value,measurement_unit), georef_no_nom%>% dplyr::mutate(measurement_unit = "Georef_no_nom"))

summary_of_differences_st_ff_vs_rien <- compute_summary_of_differences(binding_st_ff, binding_st_species_year, "Dimensions year/species/fishing_fleet", "Dimensions year/species") %>% dplyr::rename("Type of data" = measurement_unit)

```

Au global les données no_nom sont très peu différentes entre les strates espèces/années et les strates espèces/année/fishing_fleet. Cependant dès qu'on ajoute de la précision dans les dimensions des strates, les différences pour les données géoreferencées supérieures aux nominales augmentent fortement.

```{r}

qflextable2(summary_of_differences_st_ff_vs_rien, caption = "Differences de données georeferencées supérieures aux nominales et géoreferencées sans nominales entre strate espèces/années/fishing_fleet et espèces années")

```


### Conclusion pour la strate espèces/années/pavillons

Augmentation prononcée par rapport à la comparaison sur dimensions espèces/années mais pas partout et pour toutes les années. Ces strates restent marginales et ne semblent pas poser de réel problème de compréhension des liens entre les jeux de données.

## Strates espèces années engins pavillons

Si on rajoute encore une dimension, ca complexifie encore et augmente forcément les données non concordantes. Une partie peut être expliquée par les NEI ou 99.9, les TUN, TUS, BIL etc.. l'important est de voir le nombre et le fait que les aggrégations ne permettent pas d'expliquer le total. On regarde pour cette strate, les données géoreferencées sup nominales et les données géoreferencées no nominales au total.


```{r include=FALSE}

sum_no_sup_st_ff_gr <- lvl0_strata$`species, year, gear_type, fishing_fleet`$sum_georef_no_nominal +lvl0_strata$`species, year, gear_type, fishing_fleet`$sum_georef_sup_nom # 5 098 630

agg_georef_st_ff_gr <- lvl0_strata$`species, year, gear_type, fishing_fleet`$tons_aggregated_georef # = 268 977
nei_nom_st_ff_gr <- lvl0_strata$`species, year, gear_type, fishing_fleet`$tons_nei_georef # 203 111.5 donc l'aggregation et les nei ne permettent pas d'expliquer les sup to nom et les no nom (même en les sommant)

```

Elles représentent un total de `r round(sum_no_sup_st_ff_gr,3)` tonnes soit `r round((sum_no_sup_st_ff_gr *100 ) /lvl0 %>% dplyr::filter(measurement_unit == "t") %>% dplyr::summarise(sum = sum(measurement_value)) %>% dplyr::pull(),3)`% des données totales.

Le nombre et la valeur de ces strates sont supérieurs. Les données NEI dans le nominal ne permettent pas d'expliquer autant de différences. Les aggrégations d'espèces non plus. Quelques exemples illustratifs.


```{r fig.cap="Georef_sup_to_nom strate espèces/engins/années/fishing_fleet"}

datatable2(lvl0_strata$`species, year, gear_type, fishing_fleet`$georef_sup_nominal)

```

---

```{r fig.cap="Georef_not_nom strate espèces/engins/années/fishing_fleet (valeurs en tonnes et en nombre)"}

datatable2(lvl0_strata$`species, year, gear_type, fishing_fleet`$georef_no_nominal_with_value)

```


```{r, cache=TRUE}

georef_sup_nom_st_gear_ff <- as.data.frame(lvl0_strata$`species, year, gear_type, fishing_fleet`$georef_sup_nominal) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(measurement_value = Difference) %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

georef_no_nom_st_gear_ff <- as.data.frame(lvl0_strata$`species, year, gear_type, fishing_fleet`$georef_no_nominal_with_value) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

species_no_nom_st_gear_ff <- pie_chart_2_default("species", georef_no_nom_st_gear_ff, second = georef_sup_nom_st_gear_ff, titre_1 = "Georef_no_nom (uniquement les tonnes)", titre_2 = "Georef_sup_nom")

gear_type_no_nom_st_gear_ff <- pie_chart_2_default("gear_type", georef_no_nom_st_gear_ff, second = georef_sup_nom_st_gear_ff, titre_1 = "Georef_no_nom (uniquement les tonnes)", titre_2 = "Georef_sup_nom")
fishing_fleet_no_nom_st_gear_ff <- pie_chart_2_default("fishing_fleet", georef_no_nom_st_gear_ff, second = georef_sup_nom_st_gear_ff, titre_1 = "Georef_no_nom (uniquement les tonnes)", titre_2 = "Georef_sup_nom")

time_coverage_analysis_list_st_gear_ff <- time_coverage_analysis(list(fonction_groupement("time_start", georef_no_nom_st_gear_ff, georef_sup_nom_st_gear_ff )), "time_start", titre_1 = "georef_no_nom (uniquement les tonnes)",titre_2 = "georef_sup_nom")

```


```{r, results='asis'}

render_subfigures(plots_list = list(species_no_nom_st_gear_ff, gear_type_no_nom_st_gear_ff, fishing_fleet_no_nom_st_gear_ff) , titles_list =list(NULL, NULL, NULL), general_title = "Characteristics of data sup to nom and data no nom (Stratas species/year/gear/fishing_fleet)")

```

On voit que les strates supérieures et les strates sans correspondance ne concernent pas les mêmes d'engins, mais les mêmes espèces notamment SKJ. On retrouve que l'aggrégation en TUN dans les georef qui peut expliquer une partie des données georef_sup_nom.

Concernant les fishing_fleet on constate que LKA et MDV sont présentes dans les deux. On note bien que l'aggrégation de toutes ces fishing_fleet en NEI ne saurait pas régler le problème des engins.

```{r, fig.cap ="Characteristics of data sup to nom and data no nom (Stratas species/year/gear/fishing_fleet)"}

time_coverage_analysis_list_st_gear_ff$plots[[1]]

```

Au final, on voit que les données sup sont inférieures aux données non présentes ainsi que moins étalées dans le temps.

# Deuxième partie: Les facteurs de conversion IOTC: Conversion des données NO en T à l'origine de données Georef_sup_nom

Les facteurs de conversion fournis par l'IOTC sont préalablement mappés pour correspondre aux standards CWP. On les utilise par la suite pour convertir les données en nombre pour un match de strates espèces/mois/gear_type/fishing_fleet/geographic_identifier (résolution plutôt fine).

```{r message=FALSE, warning=FALSE, cache=FALSE, include=FALSE}

CA_RAISED_FILTERED_NO_FLEET <- read_csv("data/CA_RAISED_FILTERED_NO_FLEET_REDUCED.csv", guess_max = 0, 
                                        col_types = cols(AVG_WEIGHT = col_double()))%>%
  mutate(geographic_identifier = FISHING_GROUND_CODE,fishing_mode = CATCH_SCHOOL_TYPE_CODE,
         unit = "no", unit_target = "t", species = SPECIES_CODE, gear_type = GEAR_CODE,source_authority = "IOTC",
         conversion_factor = AVG_WEIGHT/1000, 
         time_start = lubridate::as_date(paste0(YEAR,"-",MONTH_START, "-01 "))) %>%
  mutate(time_end =lubridate::ceiling_date(time_start, "month") - 1 ) %>%
  select(gear_type	,source_authority,	species	,geographic_identifier,	time_start,	time_end,	unit	,unit_target,	conversion_factor, fishing_mode) %>% mutate(measurement_value = conversion_factor) %>% 
  select(-conversion_factor) %>% dplyr::rename(measurement_unit = unit) %>% dplyr::select(-unit_target)


options("OutDec" = ".")
source("https://raw.githubusercontent.com/firms-gta/geoflow-tunaatlas/master/tunaatlas_scripts/pre-harmonization/map_codelists_no_DB.R")

mapping_codelist <-map_codelists_no_DB("catch", mapping_dataset = "https://raw.githubusercontent.com/fdiwg/fdi-mappings/main/global/firms/gta/codelist_mapping_rfmos_to_global.csv", 
                                       dataset_to_map = CA_RAISED_FILTERED_NO_FLEET, 
                                       mapping_keep_src_code = FALSE, summary_mapping = TRUE, source_authority_to_map = c("IOTC")) 


IOTC_conv_fact_mapped <- mapping_codelist$dataset_mapped 
    
IOTC_conv_fact_mapped <- IOTC_conv_fact_mapped %>% 
          dplyr::mutate(gear_type = as.character(gear_type), time_start = as.character(time_start)) %>% 
          dplyr::mutate(year = as.character(lubridate::year(time_start))) %>% dplyr::rename(conversion_factors = measurement_value)  %>% dplyr::mutate(time_end = as.character(time_end))%>%  dplyr::mutate(geographic_identifier = as.character(geographic_identifier)) %>% dplyr::select(-measurement_unit) %>% dplyr::mutate(conversion_factors = round(conversion_factors, 6)) %>% dplyr::distinct()

IOTC_conv_fact_mapped_not_distinct <- IOTC_conv_fact_mapped %>% dplyr::group_by(across(-conversion_factors)) %>%
    dplyr::mutate(not_distinct = n_distinct(conversion_factors)) %>% dplyr::arrange(desc(not_distinct)) %>% dplyr::filter(not_distinct != 1)

IOTC_conv_fact_mapped <- IOTC_conv_fact_mapped %>% dplyr::group_by(across(-conversion_factors))%>% dplyr::summarise(conversion_factors = min(conversion_factors))

```

<!-- Parmi ces données, il y en a qui ont des facteurs de conversion identiques pour une même strate engin/espèces/fishing_fleet/time_start/geographic_identifier, cela semble provenir du mapping. Ca concerne environ `r nrow(IOTC_conv_fact_mapped_not_distinct)`. On propose de prendre le minimum des facteurs de conversion pour chaque strate en double. Plus d'actualité-->

```{r include=FALSE}

lvl0_conv <- lvl0 %>% 
          dplyr::mutate(time_start = as.character(time_start))%>% 
                                                             dplyr::mutate(time_end = as.character(time_end))%>% 
                                                             dplyr::mutate(geographic_identifier = as.character(geographic_identifier))

lvl0_tons <- lvl0_conv %>% dplyr::filter(measurement_unit == "t") 

# On convertit que les données en nombre. Donc on prends ces données et on cherche pour chaque strate 'time_start, engin, species, geographic_identifier' s'il y a un facteur de conversion. S'il y en a un, on multiplie la valeur en nombre par le facteur de conversion et on obtient une valeur en tonnes.

lvl0_number <- lvl0_conv  %>% dplyr::filter(measurement_unit == "no") %>% dplyr::inner_join(IOTC_conv_fact_mapped, by = c("source_authority", "time_start", "time_end", "geographic_identifier","gear_type", "species", "fishing_mode")) %>% 
          dplyr::mutate(measurement_value = measurement_value * conversion_factors) %>% 
          dplyr::mutate(measurement_unit = "t") %>% 
          dplyr::select(colnames(lvl0)) 

lvl0_upgraded <- rbind(lvl0_number, lvl0_tons)
        
list_stratalist <- list(c("species", "year") , c("species", "year", "gear_type"),  c("species", "year", "gear_type", "fishing_fleet"))

lvl0_strata_upgraded <- compare_nominal_georef_corrected(nominal , lvl0_upgraded, list_strata = list_stratalist)

        lvl0_conv_n_only <-lvl0 %>% 
          dplyr::mutate(time_start = as.character(time_start))%>% 
                                                             dplyr::mutate(time_end = as.character(time_end))%>% 
                                                             dplyr::mutate(geographic_identifier = as.character(geographic_identifier)) %>% 
          group_by(time_start,time_end, species, fishing_fleet, gear_type, source_authority, fishing_mode, geographic_identifier) %>%
            dplyr::mutate(numberunit = n_distinct(measurement_unit)) # on regarde les strates ayant deux unités différentes, on ne convertit que elles
        
        lvl0_onlynumber <- lvl0_conv_n_only %>% dplyr::filter(measurement_unit == "no" & numberunit ==1)%>% 
          dplyr::select(colnames(lvl0_conv_n_only))
        
        lvl0_onlytons_and_number_tons <- lvl0_conv_n_only %>% dplyr::filter(!(measurement_unit == "no" & numberunit ==1))%>% 
          dplyr::select(colnames(lvl0_conv_n_only)) %>% dplyr::filter(measurement_unit != "no")
        
        only_number_raised <- lvl0_onlynumber%>% dplyr::inner_join(IOTC_conv_fact_mapped, by = c("source_authority", "time_start", "time_end", "geographic_identifier","gear_type", "species", "fishing_mode")) %>% 
          dplyr::mutate(measurement_value = measurement_value * conversion_factors) %>% 
          dplyr::mutate(measurement_unit = "t") %>% 
          dplyr::select(colnames(lvl0_conv_n_only))
        
        lvl0_onlytons_and_number_tons_without_number <- lvl0_onlytons_and_number_tons %>%  dplyr::filter(measurement_unit != "no")
        
        lvl0_upgraded_st_only_no <- rbind(only_number_raised, lvl0_onlytons_and_number_tons_without_number)
        
        lvl0_upgraded_st_only_no <- lvl0_upgraded_st_only_no %>%
          dplyr::ungroup() %>%
          dplyr::group_by(across(-measurement_value)) %>% 
          dplyr::summarise(measurement_value = sum(measurement_value, na.rm = TRUE), .groups = 'drop')
        
        # list_stratalist <- list(c("species", "year")) #, c("species", "year", "gear_type"),  c("species", "year", "gear_type", "fishing_fleet")

lvl0_strata_upgraded_only_number <- compare_nominal_georef_corrected(nominal , lvl0_upgraded_st_only_no, list_strata = list_stratalist)

```

## Conversion de toutes les données NO ***(méthode A)***

On regarde l'impact de la conversion de toutes les captures en "no" sur les strates georef_sup_nom. Il n'y aura pas d'impact sur le nombre de strates georef_no_nom mais uniquement sur les valeurs totales, au vu du fait que pour les strates espèces/années, il n'y a que des espèces aggrégées en georef_no_nom on s'affranchit par la suite de l'analyse de ces strates. 

```{r}

georef_sup_nom_conv <- as.data.frame(lvl0_strata_upgraded$`species, year`$georef_sup_nominal) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(measurement_value = Difference) %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

georef_no_nom_conv_number_only <- as.data.frame(lvl0_strata_upgraded_only_number$`species, year`$georef_no_nominal_with_value) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(time_start = as.character(year))

georef_sup_nom_conv_number_only <- as.data.frame(lvl0_strata_upgraded_only_number$`species, year`$georef_sup_nominal) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(measurement_value = Difference) %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

species_no_nom_conv_number_only <- pie_chart_2_default("species", georef_sup_nom_conv, second = georef_sup_nom_conv_number_only, titre_1 = "georef_sup_nom_conv", titre_2 = "georef_sup_nom_conv_number_only")

```

```{r}

species_no_nom_conv <- pie_chart_2_default("species", georef_sup_nom, second = georef_sup_nom_conv, titre_1 = "Georef_sup_nom", titre_2 = "Georef_sup_nom_conv")

time_coverage_analysis_list_conv_init <- time_coverage_analysis(list(fonction_groupement("time_start", georef_sup_nom, georef_sup_nom_conv )), "time_start", titre_1 = "Georef_sup_nom",titre_2 = "Georef_sup_nom_conv")

```

```{r, results='asis'}

render_subfigures(plots_list = list(species_no_nom_conv, time_coverage_analysis_list_conv_init$plots[[1]]) , titles_list =list(NULL, NULL), general_title = "Characteristics of data sup to nom after and before conversion for strata species/year")

```

La conversion de toute les données NO concerne surtout BET et ALB qui crée des géoreferencées sup_nom par rapport au level0, ainsi que SWOIl n'y a pas de création de georef_sup_nom pour SKJ. 

Les années concernées sont plus nombreuses également, ce ne sont pas juste les mêmes années qui sont augmentées.

```{r}
summary_of_differences <- compute_summary_of_differences(georef_sup_nom, georef_sup_nom_conv, "georef_sup_nom", "georef_sup_nom_conv")   

  groupping_differences_list <- groupping_differences(georef_sup_nom, georef_sup_nom_conv, c("time_start", "Difference"), "geographic_identifier", NULL)
  
  Groupped_all <- groupping_differences_list$Groupped_all

groupement_diff_espece <- fonction_groupement(these_col = "species",georef_sup_nom, georef_sup_nom_conv)
compare_strata_differences_list <- compare_strata_differences(georef_sup_nom, georef_sup_nom_conv, Groupped_all, "georef_sup_nom", "georef_sup_nom_conv", parameter_columns_to_keep = c("Precision", "measurement_unit", "Values dataset 1",
                                                                               "Values dataset 2", "Loss / Gain",
                                                                               "Difference (in %)", "Dimension",
                                                                               "Difference in value"))

# lvl0 %>% dplyr::group_by(measurement_unit) %>% dplyr::summarise(sum = sum(measurement_value)) # tonnes: 21 582 058

```

La différence totale en tonnes est de plus de 2 millions de tonnes en plus (pour strates espèces/années), c'est à dire environ 10% de la valeur en tonnes du niveau 0 et 7% de la valeur après conversion.

### Au total par espèces

```{r}

lvl0_strata_species <- compare_nominal_georef_corrected(nominal , lvl0_upgraded %>% dplyr::filter(measurement_unit == "t"), list_strata = c("species"))

```

```{r}

qflextable2(lvl0_strata_species$species$georef_sup_nominal, captionn = "Total after conversion for each species and comparison to nominal (on corresponding years)")

```

## Conversion des données NO pour strate uniquement NO ***(méthode B)***

**Hypothèses: Les facteurs de conversion ne sont pas appliquables aux donnés sur des strates ayant des valeurs en nombre et en tonnes. **

**Proposition: On convertit les données du niveau 0 uniquement pour les strates qui possèdent une seule unité, en nombre, pour les dimensions suivantes espèces/engin/fishing_fleet/année/geographic_identifier.**  
On garde geographic_identifier comme dimension excluante car on a remarqué que certaines strates dupliquées pour des mêmes dimensions espèces/engin/year/fishing_fleet n'ont pas les mêmes géoreferencement pour les deux unités. Il est possible de définir les strates dupliquées no/mt autrement.

On analyse les différences entre cette **méthode B** et la **méthode A**. 

```{r, cache=TRUE}

georef_sup_nom_converted <- as.data.frame(lvl0_strata_upgraded$`species, year`$georef_sup_nominal) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(measurement_value = Difference) %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

georef_no_nom_converted <- as.data.frame(lvl0_strata_upgraded$`species, year`$georef_no_nominal_with_value) %>% dplyr::mutate(measurement_unit = "t")  %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

binding_converted <- rbind(georef_sup_nom_converted %>% dplyr::mutate(measurement_unit = "Georef_sup_nom") %>% dplyr::select(species, year, time_start,measurement_value, measurement_unit), georef_no_nom_converted%>% dplyr::mutate(measurement_unit = "Georef_no_nom"))

georef_sup_nom_converted_only_number <- as.data.frame(lvl0_strata_upgraded_only_number$`species, year`$georef_sup_nominal) %>% dplyr::mutate(measurement_unit = "t") %>% dplyr::mutate(measurement_value = Difference) %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

georef_no_nom_converted_only_number <- as.data.frame(lvl0_strata_upgraded_only_number$`species, year`$georef_no_nominal_with_value) %>% dplyr::mutate(measurement_unit = "t")  %>% dplyr::mutate(time_start = paste0(year , "-01-01"))

binding_converted_only_number <- rbind(georef_sup_nom_converted_only_number %>% dplyr::mutate(measurement_unit = "Georef_sup_nom") %>% dplyr::select(species, year, time_start,measurement_value, measurement_unit), georef_no_nom_converted_only_number%>% dplyr::mutate(measurement_unit = "Georef_no_nom"))

summary_of_differences_converted_vs_only_number <- compute_summary_of_differences(binding_converted, binding_converted_only_number, "Méthode A", "Méthode B") %>% dplyr::rename("Type of data" = measurement_unit)
```

```{r}
qflextable2(summary_of_differences_converted_vs_only_number, caption = "Difference between two methods of raising")
```

Il y a moins de données problématiques créées avec la méthode B.

```{r}

species_no_nom_conv_number_only

```

On voit qu'avec la méthode B on ajoute uniquement des données georef_sup_nom pour une espèce: BET et pas pour YFT. C'est plus cohérent avec la répartition (attention qui concerne uniquement 3 strates) des données georef_sup_nom du level0. Cette méthode réduit également l'augmentation importante (46%) en proportion des données georef_sup_nom pour BET.

```{r}

time_coverage_analysis_list_conv <- time_coverage_analysis(list(fonction_groupement("time_start", georef_sup_nom_conv, georef_sup_nom_conv_number_only )), "time_start", titre_1 = "georef_sup_nom_conv",titre_2 = "georef_sup_nom_conv_number_only")


time_coverage_analysis_list_conv_only_number_init <- time_coverage_analysis(list(fonction_groupement("time_start", georef_sup_nom_conv_number_only, georef_sup_nom )), "time_start", titre_1 = "georef_sup_nom_conv_number_only",titre_2 = "georef_sup_nom")
```


```{r, results='asis'}

render_subfigures(plots_list = list(time_coverage_analysis_list_conv$plots[[1]], time_coverage_analysis_list_conv_only_number_init$plots[[1]]) , titles_list =list("Comparaison georef_sup_nom traitement A et traitement B (fig.1)", "Comparaison des valeurs georef_sup_nom entre le traitement B et les données initiales (fig.2)"), general_title = "Comparaison des valeurs totales de strates supérieures en géoreferencées qu'en nominales au cours du temps pour les strates (year/species)")

```

On voit qu'en ne convertissant que les strates qui sont uniquement en NO on réduit fortement le total des données geref_sup_nom par rapport à une conversion totale (fig.1). Il reste un ajout par rapport aux données initiales mais cela reste relativement marginal/cohérent avec les données de départ, en plus de concerner uniquement des données avant 1990 (fig.2).

**Conclusion: Le fort dépassement des données nominales par les données géoreferencées converties pourrait venir soit :
- d'un problème lors de la méthode de conversion 
- d'un problème sur les données avec deux unités (qui seraient en fait des dupliquas)
- de facteurs de conversion calculés sur la base de ces données avec par exmemple un calcul effectué sur la base des nominales mais sans retrait de l'équivalent en tonnes géoreferencés.**

## Infirmation ou confirmation méthode B

On calcule les facteurs de conversion moyen qu'il devrait y avoir pour que les données géoreferencées en nombre soit converties et atteignent les données nominales. 
On ne s'intéresse qu'aux strates ou il y a des données en nombre et en tonnes et on s'intéresse à la cohérence des facteurs de conversion pour atteindre 100% des données nominales pour la même strate. Si les facteurs de conversion sont trop importants on ne peut rien en conclure car les données nominales doivent être supérieures aux données géoreferencées et ici on fait une conversion en même temps qu'un raise. Cependant si les facteurs de conversion sont très bas, on peut supposer une incohérence entre les deux jeux de données.

```{r}


calculate_raising_factors <- function(nominal_df, lvl0_conv_df, strata_cols) {
  
  lvl0_conv_only_double_unit <-lvl0_conv_df %>% 
        dplyr::mutate(year = lubridate::year(time_start)) %>%
    dplyr::group_by(across(all_of(strata_cols))) %>%
            dplyr::mutate(numberunit = n_distinct(measurement_unit)) %>% dplyr::rowwise()%>% dplyr::filter(numberunit != 1 | (numberunit == 2 &  measurement_unit == "no"))
  
  # Regrouper les données du dataframe nominal selon les strates et calculer la somme des valeurs
  nominal_groupped <- nominal_df %>%
    dplyr::mutate(year = lubridate::year(time_start)) %>%
    dplyr::group_by(across(all_of(strata_cols))) %>%
    dplyr::summarise(measurement_value = sum(measurement_value), .groups = 'drop')
  
  # Regrouper les données du dataframe lvl0_conv selon les strates et les unités de mesure, puis pivoter les données
  lvl0_conv_groupped <- lvl0_conv_only_double_unit %>%
    dplyr::mutate(year = lubridate::year(time_start)) %>%
    dplyr::group_by(across(all_of(strata_cols)), measurement_unit) %>%
    dplyr::summarise(measurement_value = sum(measurement_value), .groups = 'drop') %>%
    tidyr::pivot_wider(names_from = measurement_unit, values_from = measurement_value)

    # Effectuer la jointure entre les deux jeux de données
  join_result <- dplyr::full_join(lvl0_conv_groupped, nominal_groupped, by = strata_cols) %>%
    dplyr::mutate(      t = dplyr::coalesce(t, 0), 
raising_factors = (measurement_value - t) / no) 
  
  return(join_result)
}

```

```{r include=FALSE}

raisingfactorfromnumber_to_nominal_t_and_no <- calculate_raising_factors(nominal, lvl0,c("species", "year", "fishing_fleet", "gear_type"))%>% dplyr::mutate("Inf_1_kilo" = ifelse(raising_factors<0.001, TRUE, FALSE))  
raisingfactorfromnumber_to_nominal_t_and_no_groupped <- raisingfactorfromnumber_to_nominal_t_and_no%>% dplyr::filter(!is.na(Inf_1_kilo)) %>% dplyr::group_by(Inf_1_kilo) %>% dplyr::summarise(Nombre_de_strates = n()) %>% dplyr::mutate(Pourcentage = (Nombre_de_strates*100)/ sum(Nombre_de_strates))

raisingfactorfromnumber_to_nominal_t_and_no_10_kilos <- calculate_raising_factors(nominal, lvl0,c("species", "year", "fishing_fleet", "gear_type"))%>% dplyr::mutate("Inf_1_kilo" = ifelse(raising_factors<0.01, TRUE, FALSE))  
raisingfactorfromnumber_to_nominal_t_and_no_10_kilos_groupped <- raisingfactorfromnumber_to_nominal_t_and_no_10_kilos%>% dplyr::filter(!is.na(Inf_1_kilo)) %>% dplyr::group_by(Inf_1_kilo) %>% dplyr::summarise(Nombre_de_strates = n()) %>% dplyr::mutate(Pourcentage = (Nombre_de_strates*100)/ sum(Nombre_de_strates))

```


```{r echo=FALSE}


qflextable2(raisingfactorfromnumber_to_nominal_t_and_no_groupped, caption = paste0("Number of strata inferior/superior to 1 kilo for analysis ", toString(c("species", "year", "fishing_fleet", "gear_type"))))

```

Parmi toutes les strates qui ont des données en nombre et en tonnes, on constate qu'il y a 227 strates pour lesquelles il faudrait un facteur de conversion de moins de 1 kilos pour ne pas dépasser les géoreferencées pour une comparaison engin/espèces/année/pavillon. Cela représente 42% des strates pour lesquelles des facteurs de conversion sont inférieures à 1 kilos ça ne permet pas d'infirmer ou de confirmer l'hypothèse que les strates no/mt sont celles qui posent problème (on aurait pu la confirmer si tous les facteurs de conversion étaient inférieures à 1 kilos).

```{r}


raisingfactorfromnumber_to_nominal_t_and_no <- calculate_raising_factors(nominal, lvl0,c("species", "year", "fishing_fleet"))%>% dplyr::mutate("Inf_1_kilo" = ifelse(raising_factors<0.001, TRUE, FALSE))  
raisingfactorfromnumber_to_nominal_t_and_no_groupped <- raisingfactorfromnumber_to_nominal_t_and_no%>% dplyr::filter(!is.na(Inf_1_kilo)) %>% dplyr::group_by(Inf_1_kilo) %>% dplyr::summarise(Nombre_de_strates = n()) %>% dplyr::mutate(Pourcentage = (Nombre_de_strates*100)/ sum(Nombre_de_strates))

```


```{r echo=FALSE}


qflextable2(raisingfactorfromnumber_to_nominal_t_and_no_groupped, caption = paste0("Number of strata inferior/superior to 1 kilo for analysis", toString(c("species", "year", "fishing_fleet"))))

```

Même en s'affranchissant de l'engin (dimension qui posait problème précédemment), il y a toujours environ 32% de facteurs de conversion qui sont inférieurs à 1 kilos.

```{r include=FALSE}

raisingfactorfromnumber_to_nominal_t_and_no <- calculate_raising_factors(nominal, lvl0,c("species", "year"))%>% dplyr::mutate("Inf_1_kilo" = ifelse(raising_factors<0.001, TRUE, FALSE))  
raisingfactorfromnumber_to_nominal_t_and_no_groupped <- raisingfactorfromnumber_to_nominal_t_and_no%>% dplyr::filter(!is.na(Inf_1_kilo)) %>% dplyr::group_by(Inf_1_kilo) %>% dplyr::summarise(Nombre_de_strates = n()) %>% dplyr::mutate(Pourcentage = (Nombre_de_strates*100)/ sum(Nombre_de_strates))

```

```{r fig.cap="Strates avec un facteur de conversion de plus ou de moins de 1 kilos (strate espèces/année)"}

qflextable(raisingfactorfromnumber_to_nominal_t_and_no%>% dplyr::filter((Inf_1_kilo)))

```

Pour une analyse espèces/années il y a tout de même 5 trates pour lesquels il faudrait un facteur de conversion moyen de moins de 1 kilos pour ne pas dépasser les nominales, 3 d'entre elles sont celles qui sont déjà supérieurs en géoreferencées qu'en nominal mais deux autres strates sont donc ajoutées.

On note que 75% des strates no/mt doivent avoir un facteur de conversion de moins de 10 kilos, pour ne pas dépasser les nominales.

```{r}

qflextable2(raisingfactorfromnumber_to_nominal_t_and_no_10_kilos_groupped, caption = paste0("Number of strata inferior/superior to 10 kilos for analysis", toString(c("species", "year", "fishing_fleet", "gear_type"))))
```


# Annexes

## Fonction de comparaison georef to nominal 

```{r echo=TRUE}

compare_nominal_georef_corrected

```

## Exploration des georef_sup_to_nom avec fishing_fleet

```{r fig.cap = "Georef sup to nom species/gear_type/fishing_fleet/year"}

df <- georef_sup_nom_st_gear_ff %>% dplyr::mutate_if(is.numeric, round)
colnames(df) <- c("Species", "Year", "Fleet", "Nominal_Value", 
                  "Georef_Tons", "Diff", "Unit", "Value", "Start_Time")

datatable2(df)

```


```{r fig.cap = "Georef sup to nom species/fishing_fleet/year"}

df <- georef_sup_nom_st_ff %>% dplyr::mutate_if(is.numeric, round)
colnames(df) <- c("Species", "Year", "Fleet", "Nominal_Value", 
                  "Georef_Tons", "Diff", "Unit", "Value", "Start_Time")

datatable2(df)

```

## Strates espèces années engins

Comme notre première intuition était de plutôt grouper les fishing_fleet que les engins pour les analyses on détaille ci-dessous l'analyse pour des strates espèces/années/engins tout fishing_fleet confondus. 

### Les données géoreferencées sans correspondance nominales (années/espèces/engins)

```{r fig.cap="Georef_no_nom strate espèces/engins/années"}

datatable2(lvl0_strata$`species, year, gear_type`$georef_no_nominal_with_value)

```

```{r include=FALSE}

species_no_nom_st_gear <- pie_chart_2_default("species", georef_no_nom_st_gear, titre_1 = "",title_yes_no =FALSE)

gear_type_no_nom_st_gear <- pie_chart_2_default("gear_type", georef_no_nom_st_gear, titre_1 = "",title_yes_no =FALSE)

sum_georef_no_nominal_st_gear <- lvl0_strata$`species, year, gear_type`$sum_georef_no_nominal

sum_nei_nominal_gr <- lvl0_strata$`species, year, gear_type`$tons_nei_nominal

```

```{r, results='asis'}

render_subfigures(list(gear_type_no_nom_st_gear, species_no_nom_st_gear), list("Codes espèces", "Codes engins"), general_title = "Proportion relative des captures géoreferencées sans strates correspondantes en nominales pour une comparaison sur des strates de dimensions espèces/années/engins")

```

Ce sont surtout en tonnes des données pour SKJ et YFT, et notamment pour 09.2 (lignes mécanisées et lignes à cannes mécaniques). Elles représenent un total de `r round(sum_georef_no_nominal_st_gear)` tonnes soit `r round((sum_georef_no_nominal_st_gear *100 ) /lvl0 %>% dplyr::filter(measurement_unit == "t") %>% dplyr::summarise(sum = sum(measurement_value)) %>% dplyr::pull(),3)`% des données totales.

### Les données georeferencées supérieures aux nominales pour les strates espèces années engin

```{r, fig.cap = "Georef_sup_to_nom strate espèces/engins/années"}

datatable2((lvl0_strata$`species, year, gear_type`$georef_sup_nominal))

```

```{r echo=FALSE}

sum_georef_sup_nominal_st_gear <- lvl0_strata$`species, year, gear_type, fishing_fleet`$sum_georef_sup_nom
georef_sup_nom_andgeoref_no_nom_st_gear <- lvl0_strata$`species, year, gear_type`$sum_georef_no_nominal + lvl0_strata$`species, year, gear_type`$sum_georef_sup_nom # 587 284.4  + 4 209 992 = 4 797 276
# lvl0_strata$`species, year, gear_type`$tons_aggregated_georef # = 268 977
# lvl0_strata$`species, year, gear_type`$tons_nei_georef # 0 

```

Elles représentent un total de `r round(sum_georef_sup_nominal_st_gear,3)` tonnes soit `r round((sum_georef_sup_nominal_st_gear *100 ) /lvl0 %>% dplyr::filter(measurement_unit == "t") %>% dplyr::summarise(sum = sum(measurement_value)) %>% dplyr::pull())`% des données totales. 


### Conclusion pour la strate espèces/années/engins

L'apparition de strates par rapport à la comparaison précédente espèces/années nous permet de faire l'hypothèse qu'il y a un report des données d'un certain engin sur d'autres (faisant que la somme pour années/espèces n'est pas sup au nom). Si c'est le cas, faut-il garder cette représentation de chaque engin pour chaque classe ou juste retirer la dimension engins pour certaines strates car les nominales ne se correspondent pas. Si on ajoute les données sans correspondance ou inférieures on obtient un total de `r round(georef_sup_nom_andgeoref_no_nom_st_gear,3)` tonnes, il n'y a ni "99.9" ni données aggregées du type TUN, TUS, BIL dans les nominales qui peuvent expliquer ces problèmes.

L'aggregation ou les données en gear 99.9 ne permettent pas d'expliquer ni les georef no nominales, ni les georef_sup_nom


On regarde la disposition temporelle pour les strates sans fishing_fleet pour voir l'impact de l'ajout ou du retrait de cette dimension i.e. la possibilité de report des captures d'une fishing_fleet sur une autre.

```{r st_gear}

georef_no_nom_sup_nom_st_gear_ff <- rbind(georef_sup_nom_st_gear_ff %>% dplyr::group_by(species, gear_type, measurement_unit, time_start) %>% dplyr::summarise(measurement_value = sum(measurement_value)),georef_no_nom_st_gear_ff %>% dplyr::select(species, time_start , gear_type, measurement_unit,  measurement_value))

georef_no_nom_sup_nom_st_gear <-rbind(georef_sup_nom_st_gear%>% dplyr::select(species, time_start, gear_type, measurement_unit, measurement_value), georef_no_nom_st_gear%>% dplyr::mutate(time_start = paste0(year , "-01-01")) %>% dplyr::select(species, time_start , gear_type, measurement_unit, measurement_value))


time_coverage_analysis_list_st_gear <- time_coverage_analysis(list(fonction_groupement("time_start", georef_no_nom_sup_nom_st_gear_ff , georef_no_nom_sup_nom_st_gear )), "time_start", titre_1 = "georef_sup_nom_st_gear_ff",titre_2 = "georef_sup_nom_st_gear") # code très compliqué parce qu'on peut pas juste comparer les strates georef sup nom, il faut absolument ajouter les georef_no_nominal quand on compare deux strates différentes parce qu'en fait les nominales ne vont pas correspondre si on regarde que les sup.

```


```{r, fig.cap = time_coverage_analysis_list_st_gear$titles[1]}

time_coverage_analysis_list_st_gear$plots[[1]]

```

Les deux courbes sont sensiblement identiques, le problème n'est donc pas augmenté par la dimension fishing_fleet. Donc le problème vient pas d'un report des données d'un fishing_fleet à un autre. On regarde les strates c(species, fishing_fleet, year) pour voir si le report pourrait plutôt être expliqué entre les gear_type (ce qu'on n'intuitait pas au début).

